<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>S24 Tablet Remote Control</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* [ ... keep all your CSS as it was ... ] */
        /* — omitted for brevity; no CSS changes needed — */
    </style>
</head>
<body>
    <div class="app-container">
        <header class="header">
            <div class="logo">
                <i class="fas fa-tablet-alt"></i>
                S24 Tablet Remote
            </div>
            <div class="connection-status">
                <div class="status-dot" id="statusDot"></div>
                <span id="statusText">Disconnected</span>
            </div>
        </header>

        <div class="mode-selector">
            <button class="mode-btn active" id="controllerBtn">
                <i class="fas fa-mobile-alt"></i>
                <span>Controller Mode</span>
                <small>Use S24 as touchpad</small>
            </button>
            <button class="mode-btn" id="receiverBtn">
                <i class="fas fa-tablet-alt"></i>
                <span>Receiver Mode</span>
                <small>Use tablet as display</small>
            </button>
        </div>

        <!-- Controller Interface (S24) -->
        <div class="main-interface active" id="controllerInterface">
            <div class="connection-panel">
                <h3>Connection Room ID</h3>
                <div class="room-id" id="roomId">Generating...</div>
                <p style="color: var(--text-gray); font-size: 0.9rem;">
                    Share this ID with your tablet to connect
                </p>
            </div>

            <div class="touchpad-area" id="touchpadArea">
                <div class="touchpad-surface">
                    <div class="virtual-cursor" id="virtualCursor"></div>
                    <div class="touch-indicator" id="touchIndicator1"></div>
                    <div class="touch-indicator" id="touchIndicator2"></div>
                </div>
            </div>

            <div class="controls-panel">
                <button class="control-btn" id="leftClickBtn">
                    <i class="fas fa-mouse-pointer"></i>
                    Left Click
                </button>
                <button class="control-btn" id="rightClickBtn">
                    <i class="fas fa-hand-pointer"></i>
                    Right Click
                </button>
                <button class="control-btn" id="doubleClickBtn">
                    <i class="fas fa-mouse"></i>
                    Double Click
                </button>
                <button class="control-btn" id="scrollUpBtn">
                    <i class="fas fa-arrow-up"></i>
                    Scroll Up
                </button>
                <button class="control-btn" id="scrollDownBtn">
                    <i class="fas fa-arrow-down"></i>
                    Scroll Down
                </button>
                <button class="control-btn" id="backBtn">
                    <i class="fas fa-arrow-left"></i>
                    Back
                </button>
            </div>

            <div class="message-log" id="controllerLog"></div>
        </div>

        <!-- Receiver Interface (Tablet) -->
        <div class="main-interface" id="receiverInterface">
            <div class="connection-panel">
                <h3>Connect to Controller</h3>
                <div class="input-group">
                    <label for="roomIdInput">Enter Room ID from your S24:</label>
                    <input type="text" id="roomIdInput" placeholder="Enter room ID..." maxlength="6">
                </div>
                <button class="connect-btn" id="connectBtn">Connect to S24</button>
            </div>

            <div class="receiver-display" id="receiverDisplay">
                <div class="display-cursor" id="displayCursor"></div>
                <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; color: var(--text-gray);">
                    <i class="fas fa-mouse-pointer" style="font-size: 3rem; margin-bottom: 1rem; opacity: 0.3;"></i>
                    <p>Waiting for controller connection...</p>
                </div>
            </div>

            <div class="message-log" id="receiverLog"></div>
        </div>
    </div>

    <script>
        class TouchpadRemote {
            constructor() {
                this.isController = true;
                this.isConnected = false;
                this.roomId = null;
                this.peerId = null;
                this.remotePeerId = null;
                this.dataChannel = null;
                this.peerConnection = null;
                this.cursor = { x: 0, y: 0 };
                this.touchStartTime = 0;
                this.lastTouchTime = 0;
                this.touchCount = 0;

                this.initializeApp();
                this.setupEventListeners();
                this.generateRoomId();
            }

            initializeApp() {
                this.elements = {
                    controllerBtn: document.getElementById('controllerBtn'),
                    receiverBtn: document.getElementById('receiverBtn'),
                    controllerInterface: document.getElementById('controllerInterface'),
                    receiverInterface: document.getElementById('receiverInterface'),
                    statusDot: document.getElementById('statusDot'),
                    statusText: document.getElementById('statusText'),
                    roomId: document.getElementById('roomId'),
                    roomIdInput: document.getElementById('roomIdInput'),
                    connectBtn: document.getElementById('connectBtn'),
                    touchpadArea: document.getElementById('touchpadArea'),
                    virtualCursor: document.getElementById('virtualCursor'),
                    displayCursor: document.getElementById('displayCursor'),
                    receiverDisplay: document.getElementById('receiverDisplay'),
                    controllerLog: document.getElementById('controllerLog'),
                    receiverLog: document.getElementById('receiverLog'),
                    touchIndicator1: document.getElementById('touchIndicator1'),
                    touchIndicator2: document.getElementById('touchIndicator2')
                };
            }

            setupEventListeners() {
                // Mode switching
                this.elements.controllerBtn.addEventListener('click', () => this.switchMode(true));
                this.elements.receiverBtn.addEventListener('click', () => this.switchMode(false));

                // Connection
                this.elements.connectBtn.addEventListener('click', () => this.connectToRoom());

                // Controller events
                this.setupTouchpadEvents();
                this.setupControlButtons();

                // Receiver events
                this.setupReceiverEvents();
            }

            switchMode(isController) {
                this.isController = isController;

                // Update UI
                this.elements.controllerBtn.classList.toggle('active', isController);
                this.elements.receiverBtn.classList.toggle('active', !isController);
                this.elements.controllerInterface.classList.toggle('active', isController);
                this.elements.receiverInterface.classList.toggle('active', !isController);

                if (isController) {
                    this.generateRoomId();
                    this.log('Switched to Controller Mode', 'info', 'controller');
                } else {
                    this.log('Switched to Receiver Mode', 'info', 'receiver');
                }
            }

            generateRoomId() {
                this.roomId = Math.random().toString(36).substr(2, 6).toUpperCase();
                this.elements.roomId.textContent = this.roomId;
                this.peerId = `controller_${this.roomId}`;
                this.log(`Room ID generated: ${this.roomId}`, 'success', 'controller');
                this.initializeSignaling();
            }

            async connectToRoom() {
                const roomId = this.elements.roomIdInput.value.trim().toUpperCase();
                if (!roomId || roomId.length !== 6) {
                    this.log('Please enter a valid 6-character room ID', 'error', 'receiver');
                    return;
                }

                this.roomId = roomId;
                this.remotePeerId = `controller_${roomId}`;
                this.peerId = `receiver_${roomId}`;
                this.log(`Connecting to room: ${roomId}`, 'info', 'receiver');
                this.initializeSignaling();
            }

            async initializeSignaling() {
                try {
                    // Create RTCPeerConnection
                    this.peerConnection = new RTCPeerConnection({
                        iceServers: [
                            { urls: 'stun:stun.l.google.com:19302' },
                            { urls: 'stun:stun1.l.google.com:19302' }
                        ]
                    });

                    // Setup event handlers
                    this.peerConnection.onicecandidate = (event) => {
                        if (event.candidate) {
                            this.log('ICE candidate generated', 'info', this.isController ? 'controller' : 'receiver');
                            // In a real implementation, you'd send this via signaling server
                            this.handleSignalingMessage({
                                type: 'ice-candidate',
                                candidate: event.candidate,
                                from: this.peerId
                            });
                        }
                    };

                    this.peerConnection.onconnectionstatechange = () => {
                        const state = this.peerConnection.connectionState;
                        this.log(`Connection state: ${state}`, 'info', this.isController ? 'controller' : 'receiver');

                        if (state === 'connected') {
                            this.setConnectionStatus(true);
                        } else if (state === 'disconnected' || state === 'failed') {
                            this.setConnectionStatus(false);
                        }
                    };

                    if (this.isController) {
                        // Controller creates data channel
                        this.dataChannel = this.peerConnection.createDataChannel('touchpad', {
                            ordered: false,
                            maxRetransmits: 0
                        });
                        this.setupDataChannel();
                    } else {
                        // Receiver listens for data channel
                        this.peerConnection.ondatachannel = (event) => {
                            this.dataChannel = event.channel;
                            this.setupDataChannel();
                        };
                    }

                    // Start real signaling
                    this.startSignaling();

                } catch (error) {
                    this.log(`Connection error: ${error.message}`, 'error', this.isController ? 'controller' : 'receiver');
                }
            }

            // Real WebRTC signaling using localStorage as a simple message broker
            async startSignaling() {
                this.log('Starting signaling process...', 'info', this.isController ? 'controller' : 'receiver');

                if (this.isController) {
                    // Controller creates offer and stores it
                    const offer = await this.peerConnection.createOffer();
                    await this.peerConnection.setLocalDescription(offer);

                    // Store offer in localStorage with room ID
                    localStorage.setItem(`offer_${this.roomId}`, JSON.stringify({
                        offer: offer,
                        timestamp: Date.now()
                    }));

                    this.log('Offer created and stored', 'success', 'controller');

                    // Listen for answer
                    this.listenForAnswer();

                } else {
                    // Receiver looks for offer and creates answer
                    this.checkForOffer();
                }
            }

            listenForAnswer() {
                const checkAnswer = () => {
                    const answerData = localStorage.getItem(`answer_${this.roomId}`);
                    if (answerData) {
                        const { answer } = JSON.parse(answerData);
                        this.peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
                        this.log('Answer received and set', 'success', 'controller');
                        localStorage.removeItem(`answer_${this.roomId}`);
                        return;
                    }
                    setTimeout(checkAnswer, 1000);
                };
                checkAnswer();
            }

            async checkForOffer() {
                const checkOffer = async () => {
                    const offerData = localStorage.getItem(`offer_${this.roomId}`);
                    if (offerData) {
                        const { offer } = JSON.parse(offerData);

                        await this.peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
                        this.log('Offer received', 'success', 'receiver');

                        // Create and store answer
                        const answer = await this.peerConnection.createAnswer();
                        await this.peerConnection.setLocalDescription(answer);

                        localStorage.setItem(`answer_${this.roomId}`, JSON.stringify({
                            answer: answer,
                            timestamp: Date.now()
                        }));

                        this.log('Answer created and stored', 'success', 'receiver');
                        localStorage.removeItem(`offer_${this.roomId}`);
                        return;
                    }
                    setTimeout(checkOffer, 1000);
                };
                checkOffer();
            }

            setupDataChannel() {
                if (!this.dataChannel) return;

                this.dataChannel.onopen = () => {
                    this.log('Data channel opened', 'success', this.isController ? 'controller' : 'receiver');
                    this.setConnectionStatus(true);
                };

                this.dataChannel.onclose = () => {
                    this.log('Data channel closed', 'warning', this.isController ? 'controller' : 'receiver');
                    this.setConnectionStatus(false);
                };

                this.dataChannel.onerror = (error) => {
                    this.log(`Data channel error: ${error}`, 'error', this.isController ? 'controller' : 'receiver');
                };

                if (!this.isController) {
                    this.dataChannel.onmessage = (event) => {
                        this.handleReceiverMessage(JSON.parse(event.data));
                    };
                }
            }

            setupTouchpadEvents() {
                const touchpad = this.elements.touchpadArea;
                let isMoving = false;
                let lastPos = { x: 0, y: 0 };

                // Mouse events
                touchpad.addEventListener('mousedown', (e) => {
                    isMoving = true;
                    this.handleTouchStart(e.clientX, e.clientY);
                });

                touchpad.addEventListener('mousemove', (e) => {
                    if (isMoving) {
                        this.handleTouchMove(e.clientX, e.clientY);
                    }
                    this.updateVirtualCursor(e);
                });

                touchpad.addEventListener('mouseup', () => {
                    isMoving = false;
                    this.handleTouchEnd();
                });

                // Touch events
                touchpad.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    this.handleTouchStart(touch.clientX, touch.clientY);
                    this.showTouchIndicator(touch.clientX, touch.clientY, 1);
                }, { passive: false });

                touchpad.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    this.handleTouchMove(touch.clientX, touch.clientY);
                    this.updateVirtualCursor(touch);
                    this.showTouchIndicator(touch.clientX, touch.clientY, 1);
                }, { passive: false });

                touchpad.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.handleTouchEnd();
                    this.hideTouchIndicators();
                });

                // Click/tap detection
                touchpad.addEventListener('click', (e) => {
                    this.sendTouchData({
                        type: 'click',
                        button: 'left',
                        x: this.cursor.x,
                        y: this.cursor.y
                    });
                    this.animateClick();
                });
            }

            updateVirtualCursor(event) {
                const rect = this.elements.touchpadArea.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;

                this.cursor.x = Math.max(0, Math.min(x, rect.width));
                this.cursor.y = Math.max(0, Math.min(y, rect.height));

                this.elements.virtualCursor.style.left = this.cursor.x + 'px';
                this.elements.virtualCursor.style.top = this.cursor.y + 'px';
            }

            showTouchIndicator(x, y, index) {
                const indicator = this.elements[`touchIndicator${index}`];
                const rect = this.elements.touchpadArea.getBoundingClientRect();
                indicator.style.left = (x - rect.left) + 'px';
                indicator.style.top = (y - rect.top) + 'px';
                indicator.style.display = 'block';
            }

            hideTouchIndicators() {
                this.elements.touchIndicator1.style.display = 'none';
                this.elements.touchIndicator2.style.display = 'none';
            }

            handleTouchStart(x, y) {
                this.touchStartTime = Date.now();
                this.log(`Touch start at (${Math.round(x)}, ${Math.round(y)})`, 'info', 'controller');
            }

            handleTouchMove(x, y) {
                const rect = this.elements.touchpadArea.getBoundingClientRect();
                const relativeX = (x - rect.left) / rect.width;
                const relativeY = (y - rect.top) / rect.height;

                this.sendTouchData({
                    type: 'move',
                    x: relativeX,
                    y: relativeY
                });
            }

            handleTouchEnd() {
                const touchDuration = Date.now() - this.touchStartTime;
                this.log(`Touch end (duration: ${touchDuration}ms)`, 'info', 'controller');
            }

            animateClick() {
                this.elements.virtualCursor.style.transform = 'translate(-50%, -50%) scale(0.7)';
                this.elements.virtualCursor.style.background = '#ef4444';

                setTimeout(() => {
                    this.elements.virtualCursor.style.transform = 'translate(-50%, -50%) scale(1)';
                    this.elements.virtualCursor.style.background = 'var(--accent-blue)';
                }, 150);
            }

            setupControlButtons() {
                document.getElementById('leftClickBtn').addEventListener('click', () => {
                    this.sendTouchData({ type: 'click', button: 'left' });
                    this.animateClick();
                });

                document.getElementById('rightClickBtn').addEventListener('click', () => {
                    this.sendTouchData({ type: 'click', button: 'right' });
                    this.animateClick();
                });

                document.getElementById('doubleClickBtn').addEventListener('click', () => {
                    this.sendTouchData({ type: 'doubleclick' });
                    this.animateClick();
                });

                document.getElementById('scrollUpBtn').addEventListener('click', () => {
                    this.sendTouchData({ type: 'scroll', direction: 'up', amount: 100 });
                });

                document.getElementById('scrollDownBtn').addEventListener('click', () => {
                    this.sendTouchData({ type: 'scroll', direction: 'down', amount: 100 });
                });

                document.getElementById('backBtn').addEventListener('click', () => {
                    this.sendTouchData({ type: 'key', key: 'back' });
                });
            }

            setupReceiverEvents() {
                // Allow cursor movement within receiver display
                this.elements.receiverDisplay.addEventListener('mousemove', (e) => {
                    if (!this.isController) {
                        const rect = this.elements.receiverDisplay.getBoundingClientRect();
                        const x = e.clientX - rect.left;
                        const y = e.clientY - rect.top;
                        this.updateDisplayCursor(x, y);
                    }
                });
            }

            sendTouchData(data) {
                if (!this.isConnected || !this.dataChannel || this.dataChannel.readyState !== 'open') {
                    this.log('Cannot send data: not connected', 'warning', 'controller');
                    return;
                }

                try {
                    this.dataChannel.send(JSON.stringify({
                        ...data,
                        timestamp: Date.now(),
                        source: 'controller'
                    }));
                    this.log(`Sent: ${data.type}`, 'info', 'controller');
                } catch (error) {
                    this.log(`Send error: ${error.message}`, 'error', 'controller');
                }
            }

            handleReceiverMessage(data) {
                this.log(`Received: ${data.type}`, 'info', 'receiver');

                switch (data.type) {
                    case 'move':
                        this.handleCursorMove(data);
                        break;
                    case 'click':
                        this.handleClick(data);
                        break;
                    case 'doubleclick':
                        this.handleDoubleClick(data);
                        break;
                    case 'scroll':
                        this.handleScroll(data);
                        break;
                    case 'key':
                        this.handleKeyPress(data);
                        break;
                }
            }

            handleCursorMove(data) {
                const rect = this.elements.receiverDisplay.getBoundingClientRect();
                const x = data.x * rect.width;
                const y = data.y * rect.height;
                this.updateDisplayCursor(x, y);
            }

            updateDisplayCursor(x, y) {
                this.elements.displayCursor.style.left = x + 'px';
                this.elements.displayCursor.style.top = y + 'px';
            }

            handleClick(data) {
                this.animateDisplayClick();
                this.log(`${data.button || 'left'} click performed`, 'success', 'receiver');

                // Simulate actual click on webpage elements
                const rect = this.elements.receiverDisplay.getBoundingClientRect();
                const x = parseFloat(this.elements.displayCursor.style.left);
                const y = parseFloat(this.elements.displayCursor.style.top);

                const elementAtPoint = document.elementFromPoint(rect.left + x, rect.top + y);
                if (elementAtPoint && elementAtPoint.click) {
                    elementAtPoint.click();
                }
            }

            handleDoubleClick(data) {
                this.animateDisplayClick();
                setTimeout(() => this.animateDisplayClick(), 200);
                this.log('Double click performed', 'success', 'receiver');
            }

            handleScroll(data) {
                const scrollContainer = this.elements.receiverDisplay;
                const scrollAmount = data.amount || 100;
                const direction = data.direction === 'up' ? -1 : 1;

                scrollContainer.scrollTop += (scrollAmount * direction);
                this.log(`Scrolled ${data.direction} by ${scrollAmount}px`, 'info', 'receiver');
            }

            handleKeyPress(data) {
                switch (data.key) {
                    case 'back':
                        if (window.history.length > 1) {
                            window.history.back();
                        }
                        this.log('Back navigation triggered', 'info', 'receiver');
                        break;
                }
            }

            animateDisplayClick() {
                this.elements.displayCursor.style.transform = 'translate(-50%, -50%) scale(1.5)';
                this.elements.displayCursor.style.background = '#ef4444';

                setTimeout(() => {
                    this.elements.displayCursor.style.transform = 'translate(-50%, -50%) scale(1)';
                    this.elements.displayCursor.style.background = 'var(--accent-blue)';
                }, 150);
            }

            setConnectionStatus(connected) {
                this.isConnected = connected;
                this.elements.statusDot.classList.toggle('connected', connected);
                this.elements.statusText.textContent = connected ? 'Connected' : 'Disconnected';

                if (connected) {
                    this.log('Connection established successfully!', 'success', this.isController ? 'controller' : 'receiver');
                } else {
                    this.log('Connection lost', 'warning', this.isController ? 'controller' : 'receiver');
                }
            }

            handleSignalingMessage(message) {
                // In a real implementation, this would go through a signaling server
                this.log(`Signaling: ${message.type}`, 'info', this.isController ? 'controller' : 'receiver');
            }

            log(message, type = 'info', target = 'both') {
                const timestamp = new Date().toLocaleTimeString();
                const logEntry = document.createElement('div');
                logEntry.className = `log-entry ${type}`;
                logEntry.textContent = `${timestamp}: ${message}`;

                if (target === 'controller' || target === 'both') {
                    this.elements.controllerLog.appendChild(logEntry.cloneNode(true));
                    this.elements.controllerLog.scrollTop = this.elements.controllerLog.scrollHeight;
                }

                if (target === 'receiver' || target === 'both') {
                    this.elements.receiverLog.appendChild(logEntry.cloneNode(true));
                    this.elements.receiverLog.scrollTop = this.elements.receiverLog.scrollHeight;
                }
            }
        }

        // Initialize the app when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            new TouchpadRemote();
        });

        // Prevent zoom on iOS
        document.addEventListener('touchmove', function(event) {
            if (event.scale !== 1) {
                event.preventDefault();
            }
        }, { passive: false });

        // Prevent default touch behaviors that might interfere
        document.addEventListener('touchstart', function(event) {
            if (event.touches.length > 1) {
                event.preventDefault();
            }
        }, { passive: false });
    </script>
</body>
</html>